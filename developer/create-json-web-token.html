---
title: 'Creación de un token web JSON (JWT)'
description: 'En este tema, aprenderá a crear un <span translate="No">Token web JSON</span> (JWT) que se puede utilizar con las restricciones de reproducción de Brightcove.'
parent: Developers
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary> 
  <!-- <br>
  <aside class="bcls-aside bcls-aside--tip">This feature is available for a specific set of customers with access to the Limited Availability phase of Brightcove Playback Restrictions.</aside> -->

  <section class="bcls-section">
    <h2 id="Introduction">Introducción</h2>

    <p>Para agregar un nivel adicional de protección al acceder a su biblioteca de videos, o para aplicar restricciones de nivel de usuario para su contenido, puede pasar un <span translate="No">Token web JSON (JWT)</span> con su llamada a Brightcove Playback API. Para crear el token, siga estos pasos:</p>
    <ol class="bcls-tasklist">
      <li><a href="#Generate_public_private_key_pair">Generar par de claves público-privadas</a></li>
      <li>
        <a href="#Register_public_key">Registre la clave pública con Brightcove</a>
      </li>
      <li>
        <a href="#Create_a_JSON_Web_Token">Crear un <span translate="No">Token web JSON</span></a>
      </li>
      <li>
        <a href="#Test_playback">Prueba de reproducción</a>
      </li>
    </ol>
  </section>

  <section class="bcls-section">
    <h2 id="Generate_public_private_key_pair">Generar par de claves público-privadas</h2>

    <p>Usted (el editor) generará un par de claves pública-privada y proporcionará la clave pública a Brightcove. Utilizará la clave privada para firmar tokens. La clave privada no se comparte con Brightcove.</p>

    <p>
      Hay muchas formas de generar el par de claves pública-privada. Aquí hay unos ejemplos:
    </p>
    <h3>
      Ejemplo de script de bash:
    </h3>
    <aside class="bcls-aside bcls-aside--information">Tenga en cuenta que el siguiente script utiliza la <strong>jq</strong> paquete para analizar JSON. Si no tiene jq instalado, consulte las instrucciones <a href="https://github.com/stedolan/jq/wiki/Installation">de instalación</a>.</aside>
    <p>
      Script de ejemplo para generar el par de claves:
    </p>
    <pre class="line-numbers"><code class="language-bash" translate="No">#!/bin/bash
set -euo pipefail

NAME=${1:-}
test -z "${NAME:-}" &amp;&amp; NAME="brightcove-playback-auth-key-$(date +%s)"
mkdir "$NAME"

PRIVATE_PEM="./$NAME/private.pem"
PUBLIC_PEM="./$NAME/public.pem"
PUBLIC_TXT="./$NAME/public_key.txt"

ssh-keygen -t rsa -b 2048 -m PEM -f "$PRIVATE_PEM" -q -N ""
openssl rsa -in "$PRIVATE_PEM" -pubout -outform PEM -out "$PUBLIC_PEM" 2&gt;/dev/null
openssl rsa -in "$PRIVATE_PEM" -pubout -outform DER | base64 &gt; "$PUBLIC_TXT"

rm "$PRIVATE_PEM".pub

echo "Public key to saved in $PUBLIC_TXT"
</code></pre>
    <p>
      Ejecute el script:
    </p>
    <pre><code class="language-bash" translate="No">$ bash keygen.sh
</code></pre>

    <details id="Example_using_Go">
      <summary>Ejemplo usando <span translate="No">Ir</span></summary>
      <p>
        Ejemplo usando el <span translate="No">Ir</span> lenguaje de programación para generar el par de claves:
      </p>
      <aside class="bcls-aside bcls-aside--tip">Si eres nuevo en <span translate="No">Ir</span> , mira el <a href="https://golang.org/">los <span translate="No">Ir</span> Lenguaje de programación</a> página principal.</aside>
      <pre class="line-numbers"><code class="language-bash" translate="No">package main
  
  import (
    "crypto/rand"
    "crypto/rsa"
    "crypto/x509"
    "encoding/base64"
    "encoding/pem"
    "flag"
    "fmt"
    "io/ioutil"
    "os"
    "path"
    "strconv"
    "time"
  )
  
  func main() {
    var out string
  
    flag.StringVar(&amp;out, "output-dir", "", "Output directory to write files into")
    flag.Parse()
  
    if out == "" {
      out = "rsa-key_" + strconv.FormatInt(time.Now().Unix(), 10)
    }
  
    if err := os.MkdirAll(out, os.ModePerm); err != nil {
      panic(err.Error())
    }
  
    priv, err := rsa.GenerateKey(rand.Reader, 2048)
    if err != nil {
      panic(err.Error())
    }
  
    privBytes := x509.MarshalPKCS1PrivateKey(priv)
  
    pubBytes, err := x509.MarshalPKIXPublicKey(priv.Public())
    if err != nil {
      panic(err.Error())
    }
  
    privOut, err := os.OpenFile(path.Join(out, "private.pem"), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
    if err != nil {
      panic(err.Error())
    }
  
    if err := pem.Encode(privOut, &amp;pem.Block{Type: "RSA PRIVATE KEY", Bytes: privBytes}); err != nil {
      panic(err.Error())
    }
  
    pubOut, err := os.OpenFile(path.Join(out, "public.pem"), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
    if err != nil {
      panic(err.Error())
    }
  
    if err := pem.Encode(pubOut, &amp;pem.Block{Type: "PUBLIC KEY", Bytes: pubBytes}); err != nil {
      panic(err.Error())
    }
  
    var pubEnc = base64.StdEncoding.EncodeToString(pubBytes)
  
    var pubEncOut = path.Join(out, "public_key.txt")
    if err := ioutil.WriteFile(pubEncOut, []byte(pubEnc+"\n"), 0600); err != nil {
      panic(err.Error())
    }
  
    fmt.Println("Public key saved in " + pubEncOut)
  }
  </code></pre>
    </details>
    <br>

    <details id="Example_using_node_js">
      <summary>Ejemplo usando node.js</summary>
      <p>
        Ejemplo usando node.js para generar el par de claves:
      </p>
      <aside class="bcls-aside bcls-aside--tip">Este ejemplo de secuencia de comandos requiere la versión de nodo 11 o posterior.</aside>
      <pre class="line-numbers"><code class="language-javascript" translate="No">var crypto = require("crypto");
  var fs = require("fs");
  
  var now = Math.floor(new Date() / 1000);
  var dir = "rsa-key_" + now;
  fs.mkdirSync(dir);
  
  crypto.generateKeyPair(
    "rsa",
    {modulusLength: 2048},
    (err, publicKey, privateKey) =&gt; {
      fs.writeFile(
        dir + "/public.pem",
        publicKey.export({ type: "spki", format: "pem" }),
        err =&gt; {}
      );
      fs.writeFile(
        dir + "/public_key.txt",
        publicKey.export({ type: "spki", format: "der" }).toString("base64") +
          "\n",
        err =&gt; {}
      );
      fs.writeFile(
        dir + "/private.pem",
        privateKey.export({ type: "pkcs1", format: "pem" }),
        err =&gt; {}
      );
    }
  );
  
  console.log("Public key saved in " + dir + "/public_key.txt");</code></pre>
    </details>
  </section>

  <section class="bcls-section">
    <h2 id="Register_public_key">Registrar clave pública</h2>
    <p>Eres propietario de la clave privada y la usarás para generar tokens firmados. Compartirá la clave pública con Brightcove para verificar sus tokens. La API de claves le permite registrar su clave pública con Brightcove.</p>

    <p>Para obtener detalles de la API, consulte la <a href="https://apis.support.brightcove.com/playback-restrictions/guides/authentication-apis.html">Usar API de autenticación</a> documento.</p>
  </section>

  <section class="bcls-section">
    <h2 id="Create_a_JSON_Web_Token">Crear un <span translate="No">Token web JSON</span></h2>

    <p>Los editores crean un <a href="https://jwt.io/introduction/" translate="No">Token web JSON</a> (JWT). El token está firmado con el algoritmo RSA utilizando el algoritmo hash SHA-256 (identificado en la especificación JWT como "<a href="https://ldapwiki.com/wiki/RS256">RS256</a>") No se admitirán otros algoritmos JWT.</p>
    <p>
      Un subconjunto del estándar <a href="https://auth0.com/docs/tokens/jwt-claims" translate="No">Reclamaciones de JSON Web Token</a> se utilizará, junto con algunas reclamaciones privadas definidas por Brightcove. Crearás un <span translate="No">Token web JSON</span> firmado con su clave privada.
    </p>
  </section>

    <section class="bcls-section">
      <h2 id="Claims_for_Static_URL_Delivery">Reclamaciones de entrega de URL estáticas</h2>
      <p>
        Las siguientes afirmaciones se pueden utilizar con la entrega de URL estática de Brightcove.
      </p>
      <aside class="bcls-aside bcls-aside--tip">Tenga en cuenta que ninguna de las reclamaciones es necesaria para la entrega de URL estáticas.</aside>

      <table class="bcls-table">
        <thead class="bcls-table__head">
          <tr>
            <th>Campo</th>
            <th>Tipo</th>
            <th>Necesario</th>
            <th>Descripción</th>
          </tr>
        </thead>
        <tbody class="bcls-table__body">
          <tr>
            <td><code translate="No">accid</code></td>
            <td>Cuerda</td>
            <td></td>
            <td>La identificación de la cuenta que posee el contenido que se está reproduciendo.</td>
          </tr>
          <tr>
            <td><code translate="No">drules</code></td>
            <td>Cuerda[]</td>
            <td></td>
            <td>Lista de ID de acción de regla de entrega para aplicar, consulte <a href="https://apis.support.brightcove.com/delivery-rules/getting-started/implementing-delivery-rules.html">Implementación de reglas de entrega</a> para detalles. Si el parámetro de consulta config_id también se establece, se ignorará, ya que esta reclamación lo anula.</td>
          </tr>
          <tr>
            <td><code translate="No">exp</code></td>
            <td>Entero</td>
            <td></td>
            <td>Hora en que esta ficha ya no será válida, en segundos desde la Época. No debe ser más de 30 días desde <code translate="No">iat</code></td>
          </tr>
          <tr>
            <td><code translate="No">iat</code></td>
            <td>Entero</td>
            <td></td>
            <td>Hora en que se emitió esta ficha, en segundos desde la Época</td>
          </tr>
          <tr>
            <td><code translate="No">conid</code></td>
            <td>Cuerda</td>
            <td></td>
            <td>Si está presente, este token solo autorizará la obtención de licencias para un ID de video específico de Video Cloud.
              <br><br>
              Debe ser una identificación de video válida. Tenga en cuenta que no se admite el ID de referencia.
            </td>
          </tr>
          <tr>
            <td><code translate="No">pro</code></td>
            <td>Cuerda</td>
            <td></td>
            <td>Especifica un tipo de protección en el caso de que haya varios disponibles para un solo video.
              <br><br>
              Valores:
              <ul>
                <li>
                  "" (predeterminado para contenido claro)
                </li>
                <li>
                  "aes128"
                </li>
                <li>
                  "widevine"
                </li>
                <li>
                  "listo para jugar"
                </li>
                <li>
                  "juego limpio"
                </li>
              </ul>
            </td>
          </tr>
          <tr>
            <td><code translate="No">vod</code></td>
            <td>Objeto</td>
            <td></td>
            <td>Contiene opciones de configuración específicas para Video-On-Demand.</td>
          </tr>
          <tr>
            <td><code translate="No">vod.ssai</code></td>
            <td>Cuerda</td>
            <td></td>
            <td>Su ID de configuración de inserción de anuncios del lado del servidor (SSAI). Esta afirmación es <strong>requerido</strong> para recuperar un HLS o un DASH VMAP.</td>
          </tr>
        </tbody>
      </table>
      <br>
      <p>
        A continuación se muestra un ejemplo de <span translate="No">Token web JSON</span> (JWT) afirma que podría usar:
      </p>
      <pre class="line-numbers"><code class="language-json" translate="No">{
// account id: JWT is only valid for this accounts
"accid":"4590388311111",
// drules: list of delivery rule IDs to be applied
"drules": ["0758da1f-e913-4f30-a587-181db8b1e4eb"]
// expires: timestamp when JWT expires
"exp":1577989732,
// issued at: timestamp when the JWT was created
"iat":1575484132,
// content id: JWT is only valid for video ID
"conid":"5805807122222",
// protection: specify a protection type in the case where multiple are available for a single video
"pro":"aes128",
// VOD specific configuration options
"vod":{
// SSAI configuration to apply
"ssai":"efcc566-b44b-5a77-a0e2-d33333333333"
}
}</code></pre>
    </section>

    <section class="bcls-section">
      <h2 id="Claims_for_Playback_Restrictions">Reclamaciones por restricciones de reproducción</h2>
      <p>
        Las siguientes afirmaciones se pueden utilizar con <a href="https://apis.support.brightcove.com/playback-restrictions/getting-started/overview-playback-restrictions.html">Restricciones de reproducción de Brightcove</a>.
      </p>
      <aside class="bcls-aside bcls-aside--information">Al usar derechos de reproducción con DRM, no puede usar AES-128.</aside> <aside class="bcls-aside bcls-aside--information">Los campos obligatorios generales son obligatorios para todas las funciones.</aside> 

      <table class="bcls-table">
        <thead class="bcls-table__head">
          <tr>
            <th style="border-bottom:1px solid #707070;">Característica</th>
            <th style="border-bottom:1px solid #707070;">Campo</th>
            <th style="border-bottom:1px solid #707070;">Tipo</th>
            <th style="border-bottom:1px solid #707070;">Requerido para la función</th>
            <th style="border-bottom:1px solid #707070;">Solo DRM</th>
            <th style="border-bottom:1px solid #707070;">Descripción</th>
          </tr>
        </thead>
        <tbody class="bcls-table__body">
          <tr>
            <td rowspan="5" style="background-color:#dbdbdb;font-weight: bold;border-bottom:1px solid #707070;">General</td>
            <td><code translate="No">accid</code></td>
            <td>Cuerda</td>
            <td>Sí</td>
            <td></td>
            <td>La identificación de la cuenta que posee el contenido que se está reproduciendo.</td>
          </tr>
          <tr>
            <td><code translate="No">exp</code></td>
            <td>Entero</td>
            <td>Sí</td>
            <td></td>
            <td>Hora en que esta ficha ya no será válida, en segundos desde la Época. No debe ser más de 30 días desde <code translate="No">iat</code></td>
          </tr>
          <tr>
            <td><code translate="No">iat</code></td>
            <td>Entero</td>
            <td>Sí</td>
            <td></td>
            <td>Hora en que se emitió esta ficha, en segundos desde la Época</td>
          </tr>
          <tr>
            <td><code translate="No">ua</code></td>
            <td>Cuerda</td>
            <td></td>
            <td></td>
            <td>Si está presente, este token solo será válido para solicitudes de este agente de usuario.
              <br><br>
              Este campo no tiene que seguir ningún formato en particular.
              <br>
              Debes tener <strong>Protección de claves de licencia</strong> activado.
            </td>
          </tr>
          <tr>
            <td><code translate="No">conid</code></td>
            <td>Cuerda</td>
            <td></td>
            <td></td>
            <td>Si está presente, este token solo autorizará la obtención de licencias para una identificación de video de Video Cloud específica.
              <br><br>
              Debe ser una identificación de video válida
              <br>
              Debes tener <strong>Protección de claves de licencia</strong> activado.
            </td>
          </tr>
          <tr>
            <td rowspan="5" style="background-color:#dbdbdb;font-weight: bold;border-bottom:1px solid #707070;">Derechos de reproducción</td>
            <td><code translate="No">pkid</code></td>
            <td>Cuerda</td>
            <td></td>
            <td></td>
            <td>La identificación de clave pública utilizada para verificar este token.
              <br><br>
              La clave pública registrada con el Servicio de autorización de reproducción de Brightcove debe utilizar el formato de clave RSA. Las claves EC creadas previamente no funcionarán.
              <br><br>
              Este campo no es obligatorio y no está validado.
            </td>
          </tr>
           <tr>
            <td><code translate="No">nbf</code></td>
            <td>Entero</td>
            <td></td>
            <td></td>
            <td>Hora en que esta ficha comenzará a ser válida, en segundos desde la Época.</td>
          </tr>
          <tr>
            <td><code translate="No">prid</code></td>
            <td>Cuerda</td>
            <td></td>
            <td></td>
            <td>A <code translate="No">playback_rights_id</code>. Se usa para anular la identificación establecida en el catálogo de este video.
              <br><br>
              Este campo no está validado
            </td>
          </tr>
           <tr>
            <td><code translate="No">tags</code></td>
            <td>Matriz &lt;Strings&gt;</td>
            <td></td>
            <td></td>
            <td>si está presente, este token solo es válido para videos que tienen los valores de etiquetas enumerados. Solo estos videos están autorizados para su reproducción.</td>
          </tr>
          <tr>
            <td><code translate="No">vids</code></td>
            <td>Matriz &lt;Strings&gt;</td>
            <td></td>
            <td></td>
            <td>Si está presente, este token solo autorizará la obtención de licencias para un conjunto de ID de video.</td>
          </tr>
          <tr>
            <td rowspan="6" style="background-color:#dbdbdb;font-weight: bold;border-bottom:1px solid #707070;">Flujos concurrentes</td>
            <td><code translate="No">uid</code></td>
            <td>Cuerda</td>
            <td>Sí</td>
            <td>Sí</td>
            <td>El ID de usuario del visor final. Este campo se utiliza para correlacionar varias sesiones para hacer cumplir Stream Concurrency.
              <br><br>
              <strong>Requerido</strong> para el registro del dispositivo
            </td>
            <!-- <td>DRM only</td> -->
          </tr>
          <tr>
            <td><code translate="No">climit</code></td>
            <td>Entero</td>
            <td>Sí</td>
            <td>Sí</td>
            <td>Cuando se incluye este campo, habilita la comprobación de la simultaneidad de la transmisión junto con las solicitudes de renovación de licencia. Este valor indica la cantidad de observadores simultáneos permitidos.
              <br><br>
              <strong>Requerido</strong> para la concurrencia de sesiones
            </td>
            <!-- <td>DRM only</td> -->
          </tr>
          <tr>
            <td><code translate="No">cbeh</code></td>
            <td>Cuerda</td>
            <td></td>
            <td>Sí</td>
            <td>Establezca el valor en <code translate="No">BLOCK_NEW</code> para habilitar los límites de transmisión simultánea para bloquear cualquier solicitud nueva, incluso del mismo usuario, cuando se alcanza el número máximo de transmisiones.
              <br><br>
              Establezca el valor en <code translate="No">BLOCK_NEW_USER</code> para bloquear cualquier solicitud nueva solo de un nuevo usuario cuando se alcanza el número máximo de transmisiones.
              <br><br>
              El valor predeterminado bloquea la transmisión más antigua cuando se alcanza el número máximo de transmisiones.
            </td>
            <!-- <td>DRM only</td> -->
          </tr>   
          <tr>
            <td><code translate="No">cexp</code></td>
            <td>Cuerda</td>
            <td></td>
            <td>Sí</td>
            <td>Caducidad simultánea de la sesión: el valor predeterminado es 2 veces la duración del contenido.
              <br><br>
              Esto define cuánto tiempo es válida la sesión, después del cual el espectador final tiene que iniciar una nueva sesión para continuar la reproducción. Ejemplo: <code translate="No">2h</code> o <code translate="No">42m</code>
            </td>
            <!-- <td>DRM only</td> -->
          </tr>
          <tr>
            <td><code translate="No">sid</code></td>
            <td>Cuerda</td>
            <td></td>
            <td>Sí</td>
            <td>Especificar el ID de sesión de la transmisión actual le permite controlar cómo se define una sesión. De forma predeterminada, una sesión se define como User-Agent (navegador) + dirección IP + identificación de video.
              <br><br>
                Por ejemplo, puede aflojar la definición de sesión a dirección IP + ID de video
            </td>
            <!-- <td>DRM only</td> -->
          </tr>
          <tr>
            <td><code translate="No">maxu</code></td>
            <td>Entero</td>
            <td>Sí</td>
            <td></td>
            <td>
              Si está presente, este token solo será válido para este número de solicitudes de licencia.
              <br><br>
              <ul>
                <li>
                  Para HLSe, los jugadores realizarán múltiples solicitudes al reproducir un video, generalmente una por reproducción. La <code translate="No">maxu</code> debe establecerse lo suficientemente alto para tener en cuenta estas solicitudes adicionales.
                </li>
                <!-- <li>
                  For DRM, one license request is made per playback
                </li> -->
              </ul>
              <strong>Requerido</strong> para seguimiento de sesiones; Solo HLSe (AES-128)
              <br>
              Debes tener <strong>Protección de claves de licencia</strong> activado.
            </td>
          </tr>
          <tr>
            <td rowspan="3" style="background-color:#dbdbdb;font-weight: bold;border-bottom:1px solid #707070;">Límites de dispositivos</td>
            <td><code translate="No">uid</code></td>
            <td>Cuerda</td>
            <td>Sí</td>
            <td>Sí</td>
            <td>El ID de usuario del visor final. Este campo se utiliza para correlacionar varias sesiones para hacer cumplir Stream Concurrency.
              <br><br>
              <strong>Requerido</strong> para el registro del dispositivo
            </td>
            <!-- <td>DRM only</td> -->
          </tr>
          <tr>
            <td><code translate="No">dlimit</code></td>
            <td>Entero</td>
            <td>Sí</td>
            <td>Sí</td>
            <td>Cuando se incluye este campo, controla cuántos dispositivos se pueden asociar con el usuario especificado (<code translate="No">uid</code>). El valor debe ser&gt; <code translate="No">0</code>.
              <br><br>
              Los dispositivos previamente permitidos seguirán funcionando si el <code translate="No">dlimit</code> el valor se elimina en solicitudes posteriores.
              <br><br>
              Ejemplo: si el valor se establece en <code translate="No">3</code>, el usuario puede jugar en los dispositivos A, B y C (todo estaría permitido). Intentar jugar en el dispositivo D sería denegado.
              <br><br>
              Si se cambia el valor a <code translate="No">1</code>, el usuario puede seguir jugando en los 3 dispositivos A, B y C, a menos que los dispositivos se revoquen manualmente mediante la administración de dispositivos con la API de derechos de <a href="https://apis.support.brightcove.com/playback-rights/references/devices-api/reference.htmlc/#operation/GetDevices">reproducción</a>.
              <br><br>
              <strong>Requerido</strong> para el registro del dispositivo
            </td>
            <!-- <td>DRM only</td> -->
          </tr>
          <tr>
            <td><code translate="No">maxip</code></td>
            <td>Entero</td>
            <td>Sí</td>
            <td></td>
            <td>Si está presente, este token solo podrá ser utilizado por este número de direcciones IP diferentes. 
              <br><br>
              <strong>Requerido</strong> para seguimiento de sesiones; Solo HLSe (AES-128)
              <br>
              Debes tener <strong>Protección de claves de licencia</strong> activado.
            </td>
          </tr>
        </tbody>
      </table>
    </section>

    <section class="bcls-section">
      <h2 id="Generate_a_token">Genera un token</h2>
      <p>
        Las bibliotecas están comúnmente disponibles para generar tokens JWT. Para obtener más detalles, consulte la <a href="https://jwt.io/" translate="No">Tokens web JSON</a> sitio.
      </p>
      <h4>
        Ejemplo de script de bash:
      </h4>
      <p>
        Script de ejemplo para generar el token JWT:
      </p>
      <pre class="line-numbers"><code class="language-bash" translate="No">#! /usr/bin/env bash
# Static header fields.
HEADER='{
	"type": "JWT",
	"alg": "RS256"
}'

payload='{
	"accid": "{your_account_id}"
}'

# Use jq to set the dynamic `iat` and `exp`
# fields on the payload using the current time.
# `iat` is set to now, and `exp` is now + 1 second.
PAYLOAD=$(
	echo "${payload}" | jq --arg time_str "$(date +%s)" \
	'
	($time_str | tonumber) as $time_num
	| .iat=$time_num
	| .exp=($time_num + 60 * 60)
	'
)

function b64enc() { openssl enc -base64 -A | tr '+/' '-_' | tr -d '='; }

function rs_sign() { openssl dgst -binary -sha256 -sign playback-auth-keys/private.pem ; }

JWT_HDR_B64="$(echo -n "$HEADER" | b64enc)"
JWT_PAY_B64="$(echo -n "$PAYLOAD" | b64enc)"
UNSIGNED_JWT="$JWT_HDR_B64.$JWT_PAY_B64"
SIGNATURE=$(echo -n "$UNSIGNED_JWT" | rs_sign | b64enc)

echo "$UNSIGNED_JWT.$SIGNATURE"
</code></pre>
      <p>
        Ejecute el script:
      </p>
      <pre><code class="language-bash" translate="No">$ bash jwtgen.sh
</code></pre>
      <br>

      <details>
        <summary>
          Ejemplo usando <span translate="No">Ir</span>
        </summary>
        <p>Aquí hay un ejemplo de una referencia. <span translate="No">Ir</span> implementación (como una herramienta cli) para generar tokens sin el uso de ninguna biblioteca de terceros:</p>
        <pre class="line-numbers"><code class="language-bash" translate="No">package main

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"encoding/pem"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"time"
)

// Header is the base64UrlEncoded string of a JWT header for the RS256 algorithm
const RSAHeader = "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9"

// Header is the base64UrlEncoded string of a JWT header for the EC256 algorithm
const ECHeader = "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9"

// Claims represents constraints that should be applied to the use of the token
type Claims struct {
	Iat   float64 `json:"iat,omitempty"`   // Issued At
	Exp   float64 `json:"exp,omitempty"`   // Expires At
	Accid string  `json:"accid,omitempty"` // Account ID
	Conid string  `json:"conid,omitempty"` // Content ID
	Maxu  float64 `json:"maxu,omitempty"`  // Max Uses
	Maxip float64 `json:"maxip,omitempty"` // Max IPs
	Ua    string  `json:"ua,omitempty"`    // User Agent
}

func main() {
	var key, algorithm string

	c := Claims{Iat: float64(time.Now().Unix())}

	flag.StringVar(&amp;key, "key", "", "Path to private.pem key file")
	flag.StringVar(&amp;c.Accid, "account-id", "", "Account ID")
	flag.StringVar(&amp;c.Conid, "content-id", "", "Content ID (eg, video_id or live_job_id)")
	flag.Float64Var(&amp;c.Exp, "expires-at", float64(time.Now().AddDate(0, 0, 1).Unix()), "Epoch timestamp (in seconds) for when the token should stop working")
	flag.Float64Var(&amp;c.Maxu, "max-uses", 0, "Maximum number of times the token is valid for")
	flag.Float64Var(&amp;c.Maxip, "max-ips", 0, "Maximum number of unique IP addresses the token is valid for")
	flag.StringVar(&amp;c.Ua, "user-agent", "", "User Agent that the token is valid for")
	flag.StringVar(&amp;algorithm, "algo", "", "Key algorithm to use for signing. Valid: ec256, rsa256")
	flag.Parse()

	if key == "" {
		fmt.Printf("missing required flag: -key\n\n")
		flag.Usage()
		os.Exit(1)
	}

	if algorithm == "" {
		fmt.Printf("missing required flag: -algo\n\n")
		flag.Usage()
		os.Exit(2)
	}

	if algorithm != "rsa256" &amp;&amp; algorithm != "ec256" {
		fmt.Printf("missing valid value for -algo flag. Valid: rsa256, ec256\n\n")
		flag.Usage()
		os.Exit(3)
	}

	if c.Accid == "" {
		fmt.Printf("missing required flag: -account-id\n\n")
		flag.Usage()
		os.Exit(4)
	}

	bs, err := json.Marshal(c)
	if err != nil {
		fmt.Println("failed to marshal token to json", err)
		os.Exit(5)
	}

	kbs, err := ioutil.ReadFile(key)
	if err != nil {
		fmt.Println("failed to read private key", err)
		os.Exit(6)
	}

	if algorithm == "rsa256" {
		processRSA256(kbs, bs)
	} else {
		processEC256(kbs, bs)
	}
}

func processRSA256(kbs, bs []byte) {
	block, _ := pem.Decode(kbs)
	if block == nil {
		fmt.Println("failed to decode PEM block containing private key")
		os.Exit(7)
	}

	if block.Type != "RSA PRIVATE KEY" {
		fmt.Println("failed to decode PEM block containing private key")
		os.Exit(8)
	}

	pKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		fmt.Println("failed to parse rsa private key", err)
		os.Exit(9)
	}

	message := RSAHeader + "." + base64.RawURLEncoding.EncodeToString(bs)

	hash := crypto.SHA256
	hasher := hash.New()
	_, _ = hasher.Write([]byte(message))
	hashed := hasher.Sum(nil)

	r, err := rsa.SignPKCS1v15(rand.Reader, pKey, hash, hashed)
	if err != nil {
		fmt.Println("failed to sign token", err)
		os.Exit(10)
	}

	sig := strings.TrimRight(base64.RawURLEncoding.EncodeToString(r), "=")

	fmt.Println(message + "." + sig)
}

func processEC256(kbs, bs []byte) {
	block, _ := pem.Decode(kbs)
	if block == nil {
		fmt.Println("failed to decode PEM block containing private key")
		os.Exit(7)
	}

	if block.Type != "EC PRIVATE KEY" {
		fmt.Println("failed to decode PEM block containing private key")
		os.Exit(8)
	}

	pkey, err := x509.ParseECPrivateKey(block.Bytes)
	if err != nil {
		fmt.Println("failed to parse ec private key", err)
		os.Exit(9)
	}

	message := ECHeader + "." + base64.RawURLEncoding.EncodeToString(bs)
	hash := sha256.Sum256([]byte(message))

	r, s, err := ecdsa.Sign(rand.Reader, pkey, hash[:])
	if err != nil {
		fmt.Println("failed to sign token", err)
		os.Exit(10)
	}

	curveBits := pkey.Curve.Params().BitSize

	keyBytes := curveBits / 8
	if curveBits%8 &gt; 0 {
		keyBytes++
	}

	rBytes := r.Bytes()
	rBytesPadded := make([]byte, keyBytes)
	copy(rBytesPadded[keyBytes-len(rBytes):], rBytes)

	sBytes := s.Bytes()
	sBytesPadded := make([]byte, keyBytes)
	copy(sBytesPadded[keyBytes-len(sBytes):], sBytes)

	out := append(rBytesPadded, sBytesPadded...)

	sig := base64.RawURLEncoding.EncodeToString(out)
	fmt.Println(message + "." + sig)
}
</code></pre>
</details>

      <h4>Resultados</h4>
      <p>
        Aquí hay un ejemplo de un token decodificado usando <a href="https://jwt.io/">https://JWT.io</a> especificando el conjunto completo de reclamaciones:
      </p>
      <p>
        ENCABEZAMIENTO:
      </p>
<pre class="line-numbers"><code class="language-json" translate="No">{
  "alg": "RS256",
  "type": "JWT"
}
</code></pre>

      <p>
        CARGA ÚTIL:
      </p>
<pre class="line-numbers"><code class="language-json" translate="No">{
  "accid": "1100863500123",
  "conid": "51141412620123",
  "exp": 1554200832,
  "iat": 1554199032,
  "maxip": 10,
  "maxu": 10,
  "ua": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36"
}
</code></pre>
    </section>

    <section class="bcls-section">
      <h2 id="Test_playback">Prueba de reproducción</h2>

      <p>Aunque no es obligatorio, es posible que desee probar la reproducción de video antes de configurar un reproductor.</p>
      <p>
        Solicitar reproducción:
      </p>
      <pre class="line-numbers"><code class="language-http" translate="No">curl -X GET \
 -H 'Authorization: Bearer {JWT}' \
 https://edge-auth.api.brightcove.com/playback/v1/accounts/{your_account_id}/videos/{your_video_id}
</code></pre>
</section>
</article>